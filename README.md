# Edge Coloring

Данный модуль реализует алгоритм для определения минимального хроматического индекса неориентированного графа на основе теоремы Визинга. Хроматический индекс — минимальное количество цветов, необходимых для раскраски рёбер графа так, чтобы смежные рёбра (имеющие общую вершину) были разного цвета.

## Теоретическая основа

**Теорема Визинга** утверждает, что:
- Любой простой неориентированный граф может быть раскрашен рёбрами с использованием не более чем **Δ + 1** цветов, где **Δ** — максимальная степень вершин графа.
- Графы делятся на два класса:
  - **Класс 1**: Графы, раскрашиваемые **Δ** цветами.
    Обычно в этот класс ребер входят те, которые не входят во 2 класс
  - **Класс 2**: Графы, требующие **Δ + 1** цветов.
    В данном классе содержаться Нечетные циклы , Графы K$_2n+1$

## Алгоритм

1. **Нормализация рёбер**:
   - Удаление дубликатов (мультирёбра не поддерживаются).
   - Упорядочивание вершин в каждом ребре (например, ребро `(u, v)` преобразуется в `(min(u, v), max(u, v))`).

2. **Определение максимальной степени вершины (Δ)**:
   - Для каждой вершины подсчитывается количество инцидентных рёбер.
   - Выбирается максимальное значение.

3. **Проверка раскраски**:
   - Сначала проверяется, можно ли раскрасить рёбра **Δ** цветами.
   - Если нет, проверяется **Δ + 1** цветов.
   - Используется алгоритм с возвратом (backtracking) для проверки всех возможных вариантов раскраски.

## Использование

### Класс `EdgeColoring`

Основной класс, реализующий интерфейс `GraphCharacteristic`.

#### Методы

- `run(Graph graph)`:
  - Возвращает хроматический индекс графа.
  - **Вход**: Граф (`Graph`) с вершинами (`Vertex`) и рёбрами (`Edge`).
  - **Выход**: Минимальное количество цветов (int).

#### Вспомогательные методы

- `normalizeEdges(List<Edge> edges)`:
  - Удаляет дубликаты и нормализует направление рёбер.

- `findMaxVertexDegree(Graph graph, List<Edge> edges)`:
  - Вычисляет максимальную степень вершин.

- `canColorEdges(Graph graph, int numColors, List<Edge> edges)`:
  - Проверяет возможность раскраски рёбер заданным количеством цветов.

- `backtrackColoring(...)`:
  - Рекурсивно перебирает варианты раскраски рёбер.


## Сложность алгоритма

Для того чтобы посчитать сложность алгоритма состоящую из нескольких функций, достаточно найти самую сложную функцию из всех.
Ее сложность и будет являться сложностью алгоритма.
В данном алгоритме все функции, кроме функции бектрекинга.
Мы проверяем 2 случая:
    - 1. **Максимальная степень вершины**
    - 2. **Максимальная степень вершины + 1**
Сложность бектрекинга это O(N$^E$)
Где N - Максимальная степень вершины, а Е - количество ребер. 
Но так как в программе 2 раза используется бектрекинг один раз где N = Δ и N = Δ + 1.
Исходя из этого можно сказать , что примерная сложность алгоритма **O((Δ+1)$^E$)**.

## Тестирование модуля

Модуль был протестирован 2 способами:

 1. **Тестирование при помощи Unit тестов**:

    - Используется **JUnit 5** для написания тестов.

    - Проверки реализованы через библиотеку **AssertJ** (`assertThat`) и стандартные методы JUnit (`assertEquals`).

    - Графы загружаются из JSON-файлов (например, `graph-k5.json`), что обеспечивает гибкость тестирования.

2. **Тестирование на сайте**:
 

## Источники

Ниже приведен список сайтов и статей из которых была взята информация, используемая в процессе разработки модуля, а также ссылки на них.

1. **Рёберная раскраска**:
    - https://ru.wikipedia.org/wiki/%D0%A0%D1%91%D0%B1%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D1%80%D0%B0%D1%81%D0%BA%D1%80%D0%B0%D1%81%D0%BA%D0%B0
   
2. **Теорема Визинга**:
    - https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%92%D0%B8%D0%B7%D0%B8%D0%BD%D0%B3%D0%B0
   
3. **Графы с цветными ребрами**:
    - https://intuit.ru/studies/courses/58/58/lecture/1720?page=1

4. **Реберная раскраска графов и хроматический индекс**:
    - https://www.bsu.ru/content/page/1416/13.pdf , стр. 216
   

